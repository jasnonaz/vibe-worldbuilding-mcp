---
import Layout from '../../../../../../layouts/Layout.astro';
import { readdir, readFile } from 'fs/promises';
import { join } from 'path';

export async function getStaticPaths() {
  const paths: { params: { world: string; taxonomy: string; entry: string } }[] = [];
  
  try {
    const items = await readdir(process.cwd());
    for (const item of items) {
      try {
        const entriesPath = join(process.cwd(), item, 'entries');
        const taxonomyDirs = await readdir(entriesPath);
        
        for (const taxonomyDir of taxonomyDirs) {
          try {
            const taxonomyEntriesPath = join(entriesPath, taxonomyDir);
            const entryFiles = await readdir(taxonomyEntriesPath);
            const entries = entryFiles
              .filter(file => file.endsWith('.md'))
              .map(file => file.replace('.md', ''));
            
            for (const entry of entries) {
              paths.push({
                params: { 
                  world: item, 
                  taxonomy: taxonomyDir, 
                  entry 
                },
              });
            }
          } catch {
            // Not a directory or no entries
          }
        }
      } catch {
        // Not a world directory or no entries
      }
    }
  } catch {
    // Error reading directory
  }

  return paths;
}

const { world, taxonomy, entry } = Astro.params;

// Read entry content
let entryContent = '';
let entryTitle = entry?.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) || 'Unknown Entry';
let taxonomyContext = '';

try {
  const entryPath = join(process.cwd(), world!, 'entries', taxonomy!, `${entry}.md`);
  entryContent = await readFile(entryPath, 'utf-8');
  
  // Extract title from markdown if present
  const titleMatch = entryContent.match(/^# (.+)$/m);
  if (titleMatch) {
    entryTitle = titleMatch[1];
  }

  // Extract taxonomy context if present
  const contextMatch = entryContent.match(/---\n\*\*Taxonomy Context\*\*: (.+?)\n---/s);
  if (contextMatch) {
    taxonomyContext = contextMatch[1];
  }
} catch {
  entryContent = `# ${entryTitle}\n\nEntry content not found.`;
}

// Check for entry image
let entryImagePath = '';
try {
  const imagesPath = join(process.cwd(), world!, 'images', taxonomy!);
  const imageFiles = await readdir(imagesPath);
  const entryImage = imageFiles.find(file => 
    file.startsWith(entry!) && (file.endsWith('.png') || file.endsWith('.jpg') || file.endsWith('.jpeg'))
  );
  if (entryImage) {
    entryImagePath = `/images/${world}/${taxonomy}/${entryImage}`;
  }
} catch {
  // Try root images directory
  try {
    const imagesPath = join(process.cwd(), world!, 'images');
    const imageFiles = await readdir(imagesPath);
    const entryImage = imageFiles.find(file => 
      file.startsWith(entry!) && (file.endsWith('.png') || file.endsWith('.jpg') || file.endsWith('.jpeg'))
    );
    if (entryImage) {
      entryImagePath = `/images/${world}/${entryImage}`;
    }
  } catch {
    // No entry image
  }
}

// Get other entries in this taxonomy for navigation
let otherEntries: string[] = [];
try {
  const entriesPath = join(process.cwd(), world!, 'entries', taxonomy!);
  const files = await readdir(entriesPath);
  otherEntries = files
    .filter(file => file.endsWith('.md') && file.replace('.md', '') !== entry)
    .map(file => file.replace('.md', ''));
} catch {
  // No other entries found
}

const worldTitle = world?.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) || 'Unknown World';
const taxonomyTitle = taxonomy?.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) || 'Unknown Taxonomy';
---

<Layout title={`${entryTitle} - ${taxonomyTitle} - ${worldTitle}`}>
  <div class="world-header">
    <nav style="margin-bottom: 1rem;">
      <a href="/worlds" style="color: #666; text-decoration: none;">All Worlds</a>
      <span style="color: #ccc; margin: 0 0.5rem;">›</span>
      <a href={`/worlds/${world}`} style="color: #666; text-decoration: none;">{worldTitle}</a>
      <span style="color: #ccc; margin: 0 0.5rem;">›</span>
      <a href={`/worlds/${world}/taxonomies/${taxonomy}`} style="color: #666; text-decoration: none;">{taxonomyTitle}</a>
      <span style="color: #ccc; margin: 0 0.5rem;">›</span>
      <span style="color: #333;">{entryTitle}</span>
    </nav>
    <h1>{entryTitle}</h1>
    <p style="color: #666;">
      {taxonomyTitle} in {worldTitle}
    </p>
  </div>

  {taxonomyContext && (
    <div class="taxonomy-context">
      <strong>Taxonomy Context:</strong> {taxonomyContext}
    </div>
  )}

  {entryImagePath && (
    <img 
      src={entryImagePath} 
      alt={entryTitle}
      class="content-image"
      style="max-height: 400px; object-fit: cover; width: 100%;"
    />
  )}

  <div style="display: grid; gap: 2rem; grid-template-columns: 1fr 300px; margin-top: 2rem;">
    <article>
      <div set:html={entryContent} />
    </article>

    <aside style="background: #f8f9fa; padding: 1.5rem; border-radius: 8px; height: fit-content;">
      <h3 style="margin-top: 0;">Navigation</h3>
      
      <div style="margin-bottom: 2rem;">
        <a 
          href={`/worlds/${world}/taxonomies/${taxonomy}`}
          style="color: #007acc; text-decoration: none; font-weight: 500;"
        >
          ← Back to {taxonomyTitle}
        </a>
      </div>

      {otherEntries.length > 0 && (
        <div>
          <h4>Other {taxonomyTitle} Entries</h4>
          <ul style="list-style: none; padding: 0; max-height: 300px; overflow-y: auto;">
            {otherEntries.map(otherEntry => (
              <li style="margin: 0.5rem 0;">
                <a 
                  href={`/worlds/${world}/taxonomies/${taxonomy}/entries/${otherEntry}`}
                  style="color: #007acc; text-decoration: none; font-size: 0.9em;"
                >
                  {otherEntry.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}
                </a>
              </li>
            ))}
          </ul>
        </div>
      )}
    </aside>
  </div>

  <div class="entry-meta">
    <p>
      <strong>Entry Type:</strong> {taxonomyTitle} • 
      <strong>World:</strong> {worldTitle}
    </p>
  </div>
</Layout>